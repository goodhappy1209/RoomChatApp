package co.roomapp.room.model;

import java.io.Serializable;
import java.util.List;
import co.roomapp.room.model.DaoSession;
import de.greenrobot.dao.DaoException;
import java.io.Serializable;
// THIS CODE IS GENERATED BY greenDAO, EDIT ONLY INSIDE THE "KEEP"-SECTIONS

// KEEP INCLUDES - put your custom includes here
// KEEP INCLUDES END
/**
 * Entity mapped to table RAMESSAGE.
 */
public class RAMessage implements Serializable{

    private Long id;
    private String body;
    private Integer bubbleType;
    private Double cellHeight;
    private Boolean commentsCount;
    private String fromJID;
    private Boolean fromMe;
    private Boolean isDelivered;
    private Boolean isLike;
    private Boolean isMoreSelected;
    private Boolean isMute;
    private Boolean isPinned;
    private Boolean isRead;
    private java.util.Date lastCommentSync;
    private java.util.Date lastEntered;
    private String lastMessageBody;
    private java.util.Date lastMessageDate;
    private String lastMessageFromJID;
    private String lastMessageFromName;
    private String lastMessageID;
    private java.util.Date lastSync;
    private Double likeRating;
    private Long likesCount;
    private java.util.Date messagedate;
    private String password;
    private String pushname;
    private String roomappid;
    private String roomJID;
    private String subject;
    private String toJID;
    private Integer type;
    private java.util.Date updatedAt;
    private Long chatSessionId;
    private Long roomId;
    private Long parentMessageId;
    private Long notificationId;
    private Long lastCommentId;

    /** Used to resolve relations */
    private transient DaoSession daoSession;

    /** Used for active entity operations. */
    private transient RAMessageDao myDao;

    private RAChatSession chatSession;
    private Long chatSession__resolvedKey;

    private RARoom room;
    private Long room__resolvedKey;

    private RAMessage parentMessage;
    private Long parentMessage__resolvedKey;

    private RANotification notification;
    private Long notification__resolvedKey;

    private RAMessage lastComment;
    private Long lastComment__resolvedKey;

    private List<RAAttachment> attachments;
    private List<RAMessage> comments;

    // KEEP FIELDS - put your custom fields here
    // KEEP FIELDS END

    public RAMessage() {
    }

    public RAMessage(Long id) {
        this.id = id;
    }

    public RAMessage(Long id, String body, Integer bubbleType, Double cellHeight, Boolean commentsCount, String fromJID, Boolean fromMe, Boolean isDelivered, Boolean isLike, Boolean isMoreSelected, Boolean isMute, Boolean isPinned, Boolean isRead, java.util.Date lastCommentSync, java.util.Date lastEntered, String lastMessageBody, java.util.Date lastMessageDate, String lastMessageFromJID, String lastMessageFromName, String lastMessageID, java.util.Date lastSync, Double likeRating, Long likesCount, java.util.Date messagedate, String password, String pushname, String roomappid, String roomJID, String subject, String toJID, Integer type, java.util.Date updatedAt, Long chatSessionId, Long roomId, Long parentMessageId, Long notificationId, Long lastCommentId) {
        this.id = id;
        this.body = body;
        this.bubbleType = bubbleType;
        this.cellHeight = cellHeight;
        this.commentsCount = commentsCount;
        this.fromJID = fromJID;
        this.fromMe = fromMe;
        this.isDelivered = isDelivered;
        this.isLike = isLike;
        this.isMoreSelected = isMoreSelected;
        this.isMute = isMute;
        this.isPinned = isPinned;
        this.isRead = isRead;
        this.lastCommentSync = lastCommentSync;
        this.lastEntered = lastEntered;
        this.lastMessageBody = lastMessageBody;
        this.lastMessageDate = lastMessageDate;
        this.lastMessageFromJID = lastMessageFromJID;
        this.lastMessageFromName = lastMessageFromName;
        this.lastMessageID = lastMessageID;
        this.lastSync = lastSync;
        this.likeRating = likeRating;
        this.likesCount = likesCount;
        this.messagedate = messagedate;
        this.password = password;
        this.pushname = pushname;
        this.roomappid = roomappid;
        this.roomJID = roomJID;
        this.subject = subject;
        this.toJID = toJID;
        this.type = type;
        this.updatedAt = updatedAt;
        this.chatSessionId = chatSessionId;
        this.roomId = roomId;
        this.parentMessageId = parentMessageId;
        this.notificationId = notificationId;
        this.lastCommentId = lastCommentId;
    }

    /** called by internal mechanisms, do not call yourself. */
    public void __setDaoSession(DaoSession daoSession) {
        this.daoSession = daoSession;
        myDao = daoSession != null ? daoSession.getRAMessageDao() : null;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getBody() {
        return body;
    }

    public void setBody(String body) {
        this.body = body;
    }

    public Integer getBubbleType() {
        return bubbleType;
    }

    public void setBubbleType(Integer bubbleType) {
        this.bubbleType = bubbleType;
    }

    public Double getCellHeight() {
        return cellHeight;
    }

    public void setCellHeight(Double cellHeight) {
        this.cellHeight = cellHeight;
    }

    public Boolean getCommentsCount() {
        return commentsCount;
    }

    public void setCommentsCount(Boolean commentsCount) {
        this.commentsCount = commentsCount;
    }

    public String getFromJID() {
        return fromJID;
    }

    public void setFromJID(String fromJID) {
        this.fromJID = fromJID;
    }

    public Boolean getFromMe() {
        return fromMe;
    }

    public void setFromMe(Boolean fromMe) {
        this.fromMe = fromMe;
    }

    public Boolean getIsDelivered() {
        return isDelivered;
    }

    public void setIsDelivered(Boolean isDelivered) {
        this.isDelivered = isDelivered;
    }

    public Boolean getIsLike() {
        return isLike;
    }

    public void setIsLike(Boolean isLike) {
        this.isLike = isLike;
    }

    public Boolean getIsMoreSelected() {
        return isMoreSelected;
    }

    public void setIsMoreSelected(Boolean isMoreSelected) {
        this.isMoreSelected = isMoreSelected;
    }

    public Boolean getIsMute() {
        return isMute;
    }

    public void setIsMute(Boolean isMute) {
        this.isMute = isMute;
    }

    public Boolean getIsPinned() {
        return isPinned;
    }

    public void setIsPinned(Boolean isPinned) {
        this.isPinned = isPinned;
    }

    public Boolean getIsRead() {
        return isRead;
    }

    public void setIsRead(Boolean isRead) {
        this.isRead = isRead;
    }

    public java.util.Date getLastCommentSync() {
        return lastCommentSync;
    }

    public void setLastCommentSync(java.util.Date lastCommentSync) {
        this.lastCommentSync = lastCommentSync;
    }

    public java.util.Date getLastEntered() {
        return lastEntered;
    }

    public void setLastEntered(java.util.Date lastEntered) {
        this.lastEntered = lastEntered;
    }

    public String getLastMessageBody() {
        return lastMessageBody;
    }

    public void setLastMessageBody(String lastMessageBody) {
        this.lastMessageBody = lastMessageBody;
    }

    public java.util.Date getLastMessageDate() {
        return lastMessageDate;
    }

    public void setLastMessageDate(java.util.Date lastMessageDate) {
        this.lastMessageDate = lastMessageDate;
    }

    public String getLastMessageFromJID() {
        return lastMessageFromJID;
    }

    public void setLastMessageFromJID(String lastMessageFromJID) {
        this.lastMessageFromJID = lastMessageFromJID;
    }

    public String getLastMessageFromName() {
        return lastMessageFromName;
    }

    public void setLastMessageFromName(String lastMessageFromName) {
        this.lastMessageFromName = lastMessageFromName;
    }

    public String getLastMessageID() {
        return lastMessageID;
    }

    public void setLastMessageID(String lastMessageID) {
        this.lastMessageID = lastMessageID;
    }

    public java.util.Date getLastSync() {
        return lastSync;
    }

    public void setLastSync(java.util.Date lastSync) {
        this.lastSync = lastSync;
    }

    public Double getLikeRating() {
        return likeRating;
    }

    public void setLikeRating(Double likeRating) {
        this.likeRating = likeRating;
    }

    public Long getLikesCount() {
        return likesCount;
    }

    public void setLikesCount(Long likesCount) {
        this.likesCount = likesCount;
    }

    public java.util.Date getMessagedate() {
        return messagedate;
    }

    public void setMessagedate(java.util.Date messagedate) {
        this.messagedate = messagedate;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public String getPushname() {
        return pushname;
    }

    public void setPushname(String pushname) {
        this.pushname = pushname;
    }

    public String getRoomappid() {
        return roomappid;
    }

    public void setRoomappid(String roomappid) {
        this.roomappid = roomappid;
    }

    public String getRoomJID() {
        return roomJID;
    }

    public void setRoomJID(String roomJID) {
        this.roomJID = roomJID;
    }

    public String getSubject() {
        return subject;
    }

    public void setSubject(String subject) {
        this.subject = subject;
    }

    public String getToJID() {
        return toJID;
    }

    public void setToJID(String toJID) {
        this.toJID = toJID;
    }

    public Integer getType() {
        return type;
    }

    public void setType(Integer type) {
        this.type = type;
    }

    public java.util.Date getUpdatedAt() {
        return updatedAt;
    }

    public void setUpdatedAt(java.util.Date updatedAt) {
        this.updatedAt = updatedAt;
    }

    public Long getChatSessionId() {
        return chatSessionId;
    }

    public void setChatSessionId(Long chatSessionId) {
        this.chatSessionId = chatSessionId;
    }

    public Long getRoomId() {
        return roomId;
    }

    public void setRoomId(Long roomId) {
        this.roomId = roomId;
    }

    public Long getParentMessageId() {
        return parentMessageId;
    }

    public void setParentMessageId(Long parentMessageId) {
        this.parentMessageId = parentMessageId;
    }

    public Long getNotificationId() {
        return notificationId;
    }

    public void setNotificationId(Long notificationId) {
        this.notificationId = notificationId;
    }

    public Long getLastCommentId() {
        return lastCommentId;
    }

    public void setLastCommentId(Long lastCommentId) {
        this.lastCommentId = lastCommentId;
    }

    /** To-one relationship, resolved on first access. */
    public RAChatSession getChatSession() {
        Long __key = this.chatSessionId;
        if (chatSession__resolvedKey == null || !chatSession__resolvedKey.equals(__key)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            RAChatSessionDao targetDao = daoSession.getRAChatSessionDao();
            RAChatSession chatSessionNew = targetDao.load(__key);
            synchronized (this) {
                chatSession = chatSessionNew;
            	chatSession__resolvedKey = __key;
            }
        }
        return chatSession;
    }

    public void setChatSession(RAChatSession chatSession) {
        synchronized (this) {
            this.chatSession = chatSession;
            chatSessionId = chatSession == null ? null : chatSession.getId();
            chatSession__resolvedKey = chatSessionId;
        }
    }

    /** To-one relationship, resolved on first access. */
    public RARoom getRoom() {
        Long __key = this.roomId;
        if (room__resolvedKey == null || !room__resolvedKey.equals(__key)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            RARoomDao targetDao = daoSession.getRARoomDao();
            RARoom roomNew = targetDao.load(__key);
            synchronized (this) {
                room = roomNew;
            	room__resolvedKey = __key;
            }
        }
        return room;
    }

    public void setRoom(RARoom room) {
        synchronized (this) {
            this.room = room;
            roomId = room == null ? null : room.getId();
            room__resolvedKey = roomId;
        }
    }

    /** To-one relationship, resolved on first access. */
    public RAMessage getParentMessage() {
        Long __key = this.parentMessageId;
        if (parentMessage__resolvedKey == null || !parentMessage__resolvedKey.equals(__key)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            RAMessageDao targetDao = daoSession.getRAMessageDao();
            RAMessage parentMessageNew = targetDao.load(__key);
            synchronized (this) {
                parentMessage = parentMessageNew;
            	parentMessage__resolvedKey = __key;
            }
        }
        return parentMessage;
    }

    public void setParentMessage(RAMessage parentMessage) {
        synchronized (this) {
            this.parentMessage = parentMessage;
            parentMessageId = parentMessage == null ? null : parentMessage.getId();
            parentMessage__resolvedKey = parentMessageId;
        }
    }

    /** To-one relationship, resolved on first access. */
    public RANotification getNotification() {
        Long __key = this.notificationId;
        if (notification__resolvedKey == null || !notification__resolvedKey.equals(__key)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            RANotificationDao targetDao = daoSession.getRANotificationDao();
            RANotification notificationNew = targetDao.load(__key);
            synchronized (this) {
                notification = notificationNew;
            	notification__resolvedKey = __key;
            }
        }
        return notification;
    }

    public void setNotification(RANotification notification) {
        synchronized (this) {
            this.notification = notification;
            notificationId = notification == null ? null : notification.getId();
            notification__resolvedKey = notificationId;
        }
    }

    /** To-one relationship, resolved on first access. */
    public RAMessage getLastComment() {
        Long __key = this.lastCommentId;
        if (lastComment__resolvedKey == null || !lastComment__resolvedKey.equals(__key)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            RAMessageDao targetDao = daoSession.getRAMessageDao();
            RAMessage lastCommentNew = targetDao.load(__key);
            synchronized (this) {
                lastComment = lastCommentNew;
            	lastComment__resolvedKey = __key;
            }
        }
        return lastComment;
    }

    public void setLastComment(RAMessage lastComment) {
        synchronized (this) {
            this.lastComment = lastComment;
            lastCommentId = lastComment == null ? null : lastComment.getId();
            lastComment__resolvedKey = lastCommentId;
        }
    }

    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
    public List<RAAttachment> getAttachments() {
        if (attachments == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            RAAttachmentDao targetDao = daoSession.getRAAttachmentDao();
            List<RAAttachment> attachmentsNew = targetDao._queryRAMessage_Attachments(id);
            synchronized (this) {
                if(attachments == null) {
                    attachments = attachmentsNew;
                }
            }
        }
        return attachments;
    }

    public void setAttachments(List<RAAttachment> _attchments)
    {
        attachments = _attchments;
    }

    public List<RAAttachment> getAttachmentsFake() {

        return attachments;
    }

    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
    public synchronized void resetAttachments() {
        attachments = null;
    }

    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
    public List<RAMessage> getComments() {
        if (comments == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            RAMessageDao targetDao = daoSession.getRAMessageDao();
            List<RAMessage> commentsNew = targetDao._queryRAMessage_Comments(id);
            synchronized (this) {
                if(comments == null) {
                    comments = commentsNew;
                }
            }
        }
        return comments;
    }

    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
    public synchronized void resetComments() {
        comments = null;
    }

    /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. */
    public void delete() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.delete(this);
    }

    /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. */
    public void update() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.update(this);
    }

    /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. */
    public void refresh() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.refresh(this);
    }

    // KEEP METHODS - put your custom methods here
    // KEEP METHODS END

}
